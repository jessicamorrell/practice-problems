<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title></title>
</head>
<body>



    <script>

// function delimiterCheck(str) {
//     //if opener then push on stack
//     //else pop previous (match) 
//     //or return false if previous isn't match of current
    
//     var isDelimiter = true;
//     var validSets = [['(', ')'], ['[', ']'], ['{', '}']];
//     var needsMatch = [];
    
//     str.split('').forEach(function(char) {

//         //check if some child array in validSets contains char
//         var isValidChar = validSets.some(x => x.indexOf(char) >= 0);
      
//         if (!isValidChar) {
//             //the character is not a valid set character - return false
//             isDelimiter = false;
//             return false;
//         }
      
//         validSets.forEach(function(set) {
//             if (set[0] === char) {
//                 //if the character is an opening character then push to needsMatch
//                 needsMatch.push(char);
//             } else if (set.indexOf(char) > 0) {
//                 //the character is not an opener, but does exist in the set
//                 //check if the last needsMatch item is the closing item for the set
//                 if (needsMatch[needsMatch.length-1] === set[0]) {
//                     //remove the last item from needsMatch - we have found its closing set character
//                     needsMatch.pop();
//                 } else {
//                     //the closing bracket was incorrectly placed so we return false
//                     isDelimiter = false;
//                     return false;
//                 }
//             }

//             return true;
//       })

//     });
   
//     if (needsMatch.length === 0 && isDelimiter) {
//         //all characters have been matched and removed from needsMatch - return true
//         return true;
//     }

//     return false;
//   }
  
  

//   var isDelimiterFinal = delimiterCheck("()[{()}][{()}]");
//   console.log("final: " + isDelimiterFinal);


    //Input:
    // [1, 2, 3]
    // 4
    //Output:
    // 4  [1,1,1,1],[1,1,2],[2,2],[1,3]


    //Input:
    // [2, 5, 3, 6]
    // 10
    //Output:
    //5 [2,2,2,2,2], [2,2,3,3], [2,2,6], [2,3,5] and [5,5]

    function countChangeOptions(validCoins, amount) {
        //add items to newOption array until newOptionTotal <= amount
        //if newOptionTotal < amount then dont add it
        //if newOption characters are the same as another option (order them to check) then dont add
        //otherwise add it
        
        //sort validCoins in ascending order
        validCoins.sort((x, y) => x - y);

        var options = [];
        var k = validCoins.length-1;

        do {
            var newOption = [];
            var j = k;

            do {
                //this do while loop creates the newOption
                //this needs work - this is not a good way to add coins to newOption
                var newOptionTotal = 0;
                if (newOption.length > 0) {
                    newOptionTotal = newOption.reduce((total, num) =>  total + num);
                }

                if (newOptionTotal + validCoins[j] > amount) {
                    j--;
                } else {
                    newOption.push(validCoins[j]);
                }

            }
            while(j > 0)

            if (newOption.reduce((total, num) =>  total + num) === amount) {
                var isUnique = true;
                //sort newOption in ascending order
                newOption.sort((x, y) => x - y);

                for (var i = 0; i < options.length; i++) {
                    //compare newOption to other options - if there is a match set isUnique to false
                    if (JSON.stringify(options[i]) === JSON.stringify(newOption)) {
                        isUnique = false;
                    }
                }

                if (isUnique) {
                    options.push(newOption);
                }
            }
            k--;
        }
        while(k > 0)

        return options;
    }

    console.log(countChangeOptions([2, 4, 1, 9, 3], 4));


    // function getFactorial(n) {
    //     var factorial = n;

    //     for (var i = n-1; i >0 ; i--) {
    //         factorial *= i;
    //     }

    //     return factorial;
    // }

    // console.log(getFactorial(10));

// //returns fibonacci number at n
// function getFibonacci(n) {
//     if (n === 0) {
//         throw "invalid input";
//     }

//     //I am opting to start the array with these values because it is less code than adding it dynamically
//     var fibs = [1, 1];

//     for (var i = 2; i < n; i++) {
//         fibs.push(fibs[i-1] + fibs[i-2])
//     }
    
//     return fibs[fibs.length-1];
// }

// console.log(getFibonacci(30));

    </script>
</body>
</html>